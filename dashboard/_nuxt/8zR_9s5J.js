import{av as w,r as _,aw as C,ax as b,W as B,ay as O,H,az as D,m as M,aA as R,N as S,K as x,aB as z,_ as E,t as N,L as I,V as K}from"./CJX7AtTl.js";import j from"./DZiS_xkF.js";const T=s=>s==="defer"||s===!1;function q(...s){var h;const o=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(o);let[a,l,e={}]=s;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=M(),p=l,v=()=>null,g=()=>t.isHydrating?t.payload.data[a]:t.static.data[a];e.server=e.server??!0,e.default=e.default??v,e.getCachedData=e.getCachedData??g,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??w.deep,e.dedupe=e.dedupe??"cancel";const u=()=>e.getCachedData(a,t)!=null;if(!t._asyncData[a]||!e.immediate){(h=t.payload._errors)[a]??(h[a]=null);const c=e.deep?_:C;t._asyncData[a]={data:c(e.getCachedData(a,t)??e.default()),pending:_(!u()),error:b(t.payload._errors,a),status:_("idle")}}const r={...t._asyncData[a]};r.refresh=r.execute=(c={})=>{if(t._asyncDataPromises[a]){if(T(c.dedupe??e.dedupe))return t._asyncDataPromises[a];t._asyncDataPromises[a].cancelled=!0}if((c._initial||t.isHydrating&&c._initial!==!1)&&u())return Promise.resolve(e.getCachedData(a,t));r.pending.value=!0,r.status.value="pending";const d=new Promise((i,n)=>{try{i(p(t))}catch(f){n(f)}}).then(async i=>{if(d.cancelled)return t._asyncDataPromises[a];let n=i;e.transform&&(n=await e.transform(i)),e.pick&&(n=F(n,e.pick)),t.payload.data[a]=n,r.data.value=n,r.error.value=null,r.status.value="success"}).catch(i=>{if(d.cancelled)return t._asyncDataPromises[a];r.error.value=R(i),r.data.value=S(e.default()),r.status.value="error"}).finally(()=>{d.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[a])});return t._asyncDataPromises[a]=d,t._asyncDataPromises[a]},r.clear=()=>V(t,a);const y=()=>r.refresh({_initial:!0}),P=e.server!==!1&&t.payload.serverRendered;{const c=x();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const n=c._nuxtOnBeforeMountCbs;B(()=>{n.forEach(f=>{f()}),n.splice(0,n.length)}),O(()=>n.splice(0,n.length))}P&&t.isHydrating&&(r.error.value||u())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):c&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?c._nuxtOnBeforeMountCbs.push(y):e.immediate&&y();const d=z();if(e.watch){const n=H(e.watch,()=>r.refresh());d&&D(n)}const i=t.hook("app:data:refresh",async n=>{(!n||n.includes(a))&&await r.refresh()});d&&D(i)}const m=Promise.resolve(t._asyncDataPromises[a]).then(()=>r);return Object.assign(m,r),m}function V(s,o){o in s.payload.data&&(s.payload.data[o]=void 0),o in s.payload._errors&&(s.payload._errors[o]=null),s._asyncData[o]&&(s._asyncData[o].data.value=void 0,s._asyncData[o].error.value=null,s._asyncData[o].pending.value=!1,s._asyncData[o].status.value="idle"),o in s._asyncDataPromises&&(s._asyncDataPromises[o].cancelled=!0,s._asyncDataPromises[o]=void 0)}function F(s,o){const a={};for(const l of o)a[l]=s[l];return a}const L={__name:"RefreshIcon",props:["refreshing"],setup(s){return(o,a)=>{const l=j;return s.refreshing?(N(),I(l,{key:0,style:{width:"1rem",height:"1rem"},"stroke-width":"4"})):K("",!0)}}},G=E(L,[["__scopeId","data-v-4b9cdb75"]]);export{G as _,q as u};
